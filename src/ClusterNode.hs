{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.12.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ClusterNode where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Rafths_Types
import qualified ClusterNode_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data RequestVote_args = RequestVote_args  { requestVote_args_req :: VoteRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVote_args_req record  
instance QC.Arbitrary RequestVote_args where 
  arbitrary = M.liftM RequestVote_args (QC.arbitrary)
  shrink obj | obj == default_RequestVote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVote_args{requestVote_args_req = requestVote_args_req obj} then P.Nothing else P.Just $ default_RequestVote_args{requestVote_args_req = requestVote_args_req obj}
    ]
from_RequestVote_args :: RequestVote_args -> T.ThriftVal
from_RequestVote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v47 -> P.Just (1, ("req",from_VoteRequest _v47))) $ requestVote_args_req record
  ]
write_RequestVote_args :: T.Protocol p => p -> RequestVote_args -> P.IO ()
write_RequestVote_args oprot record = T.writeVal oprot $ from_RequestVote_args record
encode_RequestVote_args :: T.StatelessProtocol p => p -> RequestVote_args -> LBS.ByteString
encode_RequestVote_args oprot record = T.serializeVal oprot $ from_RequestVote_args record
to_RequestVote_args :: T.ThriftVal -> RequestVote_args
to_RequestVote_args (T.TStruct fields) = RequestVote_args{
  requestVote_args_req = P.maybe (requestVote_args_req default_RequestVote_args) (\(_,_val49) -> (case _val49 of {T.TStruct _val50 -> (to_VoteRequest (T.TStruct _val50)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestVote_args _ = P.error "not a struct"
read_RequestVote_args :: T.Protocol p => p -> P.IO RequestVote_args
read_RequestVote_args iprot = to_RequestVote_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestVote_args)
decode_RequestVote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVote_args
decode_RequestVote_args iprot bs = to_RequestVote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVote_args) bs
typemap_RequestVote_args :: T.TypeMap
typemap_RequestVote_args = Map.fromList [(1,("req",(T.T_STRUCT typemap_VoteRequest)))]
default_RequestVote_args :: RequestVote_args
default_RequestVote_args = RequestVote_args{
  requestVote_args_req = default_VoteRequest}
data RequestVote_result = RequestVote_result  { requestVote_result_success :: VoteResponse
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVote_result_success record  
instance QC.Arbitrary RequestVote_result where 
  arbitrary = M.liftM RequestVote_result (QC.arbitrary)
  shrink obj | obj == default_RequestVote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVote_result{requestVote_result_success = requestVote_result_success obj} then P.Nothing else P.Just $ default_RequestVote_result{requestVote_result_success = requestVote_result_success obj}
    ]
from_RequestVote_result :: RequestVote_result -> T.ThriftVal
from_RequestVote_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v53 -> P.Just (0, ("success",from_VoteResponse _v53))) $ requestVote_result_success record
  ]
write_RequestVote_result :: T.Protocol p => p -> RequestVote_result -> P.IO ()
write_RequestVote_result oprot record = T.writeVal oprot $ from_RequestVote_result record
encode_RequestVote_result :: T.StatelessProtocol p => p -> RequestVote_result -> LBS.ByteString
encode_RequestVote_result oprot record = T.serializeVal oprot $ from_RequestVote_result record
to_RequestVote_result :: T.ThriftVal -> RequestVote_result
to_RequestVote_result (T.TStruct fields) = RequestVote_result{
  requestVote_result_success = P.maybe (requestVote_result_success default_RequestVote_result) (\(_,_val55) -> (case _val55 of {T.TStruct _val56 -> (to_VoteResponse (T.TStruct _val56)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_RequestVote_result _ = P.error "not a struct"
read_RequestVote_result :: T.Protocol p => p -> P.IO RequestVote_result
read_RequestVote_result iprot = to_RequestVote_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestVote_result)
decode_RequestVote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVote_result
decode_RequestVote_result iprot bs = to_RequestVote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVote_result) bs
typemap_RequestVote_result :: T.TypeMap
typemap_RequestVote_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VoteResponse)))]
default_RequestVote_result :: RequestVote_result
default_RequestVote_result = RequestVote_result{
  requestVote_result_success = default_VoteResponse}
data AppendEntries_args = AppendEntries_args  { appendEntries_args_req :: AppendRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AppendEntries_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` appendEntries_args_req record  
instance QC.Arbitrary AppendEntries_args where 
  arbitrary = M.liftM AppendEntries_args (QC.arbitrary)
  shrink obj | obj == default_AppendEntries_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AppendEntries_args{appendEntries_args_req = appendEntries_args_req obj} then P.Nothing else P.Just $ default_AppendEntries_args{appendEntries_args_req = appendEntries_args_req obj}
    ]
from_AppendEntries_args :: AppendEntries_args -> T.ThriftVal
from_AppendEntries_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v59 -> P.Just (1, ("req",from_AppendRequest _v59))) $ appendEntries_args_req record
  ]
write_AppendEntries_args :: T.Protocol p => p -> AppendEntries_args -> P.IO ()
write_AppendEntries_args oprot record = T.writeVal oprot $ from_AppendEntries_args record
encode_AppendEntries_args :: T.StatelessProtocol p => p -> AppendEntries_args -> LBS.ByteString
encode_AppendEntries_args oprot record = T.serializeVal oprot $ from_AppendEntries_args record
to_AppendEntries_args :: T.ThriftVal -> AppendEntries_args
to_AppendEntries_args (T.TStruct fields) = AppendEntries_args{
  appendEntries_args_req = P.maybe (appendEntries_args_req default_AppendEntries_args) (\(_,_val61) -> (case _val61 of {T.TStruct _val62 -> (to_AppendRequest (T.TStruct _val62)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AppendEntries_args _ = P.error "not a struct"
read_AppendEntries_args :: T.Protocol p => p -> P.IO AppendEntries_args
read_AppendEntries_args iprot = to_AppendEntries_args <$> T.readVal iprot (T.T_STRUCT typemap_AppendEntries_args)
decode_AppendEntries_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AppendEntries_args
decode_AppendEntries_args iprot bs = to_AppendEntries_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AppendEntries_args) bs
typemap_AppendEntries_args :: T.TypeMap
typemap_AppendEntries_args = Map.fromList [(1,("req",(T.T_STRUCT typemap_AppendRequest)))]
default_AppendEntries_args :: AppendEntries_args
default_AppendEntries_args = AppendEntries_args{
  appendEntries_args_req = default_AppendRequest}
data AppendEntries_result = AppendEntries_result  { appendEntries_result_success :: AppendResponse
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AppendEntries_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` appendEntries_result_success record  
instance QC.Arbitrary AppendEntries_result where 
  arbitrary = M.liftM AppendEntries_result (QC.arbitrary)
  shrink obj | obj == default_AppendEntries_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AppendEntries_result{appendEntries_result_success = appendEntries_result_success obj} then P.Nothing else P.Just $ default_AppendEntries_result{appendEntries_result_success = appendEntries_result_success obj}
    ]
from_AppendEntries_result :: AppendEntries_result -> T.ThriftVal
from_AppendEntries_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v65 -> P.Just (0, ("success",from_AppendResponse _v65))) $ appendEntries_result_success record
  ]
write_AppendEntries_result :: T.Protocol p => p -> AppendEntries_result -> P.IO ()
write_AppendEntries_result oprot record = T.writeVal oprot $ from_AppendEntries_result record
encode_AppendEntries_result :: T.StatelessProtocol p => p -> AppendEntries_result -> LBS.ByteString
encode_AppendEntries_result oprot record = T.serializeVal oprot $ from_AppendEntries_result record
to_AppendEntries_result :: T.ThriftVal -> AppendEntries_result
to_AppendEntries_result (T.TStruct fields) = AppendEntries_result{
  appendEntries_result_success = P.maybe (appendEntries_result_success default_AppendEntries_result) (\(_,_val67) -> (case _val67 of {T.TStruct _val68 -> (to_AppendResponse (T.TStruct _val68)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_AppendEntries_result _ = P.error "not a struct"
read_AppendEntries_result :: T.Protocol p => p -> P.IO AppendEntries_result
read_AppendEntries_result iprot = to_AppendEntries_result <$> T.readVal iprot (T.T_STRUCT typemap_AppendEntries_result)
decode_AppendEntries_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AppendEntries_result
decode_AppendEntries_result iprot bs = to_AppendEntries_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AppendEntries_result) bs
typemap_AppendEntries_result :: T.TypeMap
typemap_AppendEntries_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AppendResponse)))]
default_AppendEntries_result :: AppendEntries_result
default_AppendEntries_result = AppendEntries_result{
  appendEntries_result_success = default_AppendResponse}
process_requestVote (seqid, iprot, oprot, handler) = do
  args <- read_RequestVote_args iprot
  (X.catch
    (do
      val <- Iface.requestVote handler (requestVote_args_req args)
      let res = default_RequestVote_result{requestVote_result_success = val}
      T.writeMessage oprot ("requestVote", T.M_REPLY, seqid) $
        write_RequestVote_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("requestVote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_appendEntries (seqid, iprot, oprot, handler) = do
  args <- read_AppendEntries_args iprot
  (X.catch
    (do
      val <- Iface.appendEntries handler (appendEntries_args_req args)
      let res = default_AppendEntries_result{appendEntries_result_success = val}
      T.writeMessage oprot ("appendEntries", T.M_REPLY, seqid) $
        write_AppendEntries_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("appendEntries", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "requestVote" -> process_requestVote (seqid,iprot,oprot,handler)
  "appendEntries" -> process_appendEntries (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
